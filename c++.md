# 基础语法

## new

> **类似`malloc`，在堆区开辟一块空间，返回指针**

```c++
int *p = new int(10);	
int *p_arr = new int[10];
int *p_arr1 = new int [3]{1, 2, 3};

delete p;
delete [] p_arr;
delete [] p_arr1;
```

## 引用&

> **给变量起别名**

```c++
int b = 10;
int &a = b; //a是b的别名， 别名一旦初始化，无法更改
int &c;  	//错误！！引用必须初始化
		 	
```

> **引用的本质**

```c++
int a = 10;

int &ref = a;		// 自动转换为int * const ref = a;所以指针的指向不可改变
ref = 20; 			//内部发现是引用，自动转换为：*ref = 20;
```

> **常量引用** 

```C++
void int(const int a, const int b){...} //因为形参为引用，所以加const防止实参被修改
```

## 函数默认参数

> **用法**

```c++
//默认参数可以不传参，用默认的，如果传参就用自己的
//如果某个位置已经有了默认参数,那么从左往右都必须有默认参数
void test(int a, int b = 2, int c =5) {
    cout << a + b + c << endl;
}//test(100,100)  #输出205

//如果函数声明有默认参数，那么函数实现就不能有默认参数

void fun(int a = 10);
void fun(int a = 5) {	//错误！！重定义默认参数
    //
}

void fun(int a = 10);	//正确
void fun(int a) {	
   	cout <<  a + 5 << endl; //输出15
}


```

## 函数占位参数

> - **语法：返回值   函数名 (`数据类型`(占位参数1)， 数据类型 = `数据类型的一个值`(占位参数2))**
> - **在调用时的占位参数必须传一个与之对应的值**

```c++
//在调用fun1时第二个参数必须传一个整型的值
void fun1(int a, int) {
    //
}
//可以有默认值。。。
void fun2(int a, int = 10) {
    //
}
```

## 函数重载

- 函数重载的要求时，函数名相同，函数参数的类型，个数，大小可以不同
- 返回值不能作为重载的条件

## 面向对象

> **只记录自己容易忘记的**

- **构造函数**，只调用一次，如果没写，默认是一个参数为空的空实现，且可以重载

- **析构函数**，不可以有参数不可以发生重载，如果没写，默认空实现

- 如果一个类创建在堆区，没有主动释放，如`delete`，那么不会就不会调用析构，会造成内存泄漏

- **拷贝构造函数**

  ```c++
  class A {
      public:
      int age;
      
      A(){}
    	A(const A &a) { //拷贝构造函数
          age = a.age;
      }  
      A(int a) { //拷贝构造函数
          age = a.age;
      }  
  };
  
  int main () {
      A a;
      a.age = 5;
      A b(a);
      cout << b.age << endl; // 5
      
      A c(); //错误，会被当作函数声明！！函数名为c返回值为A类型
      
      //匿名对象，创建成功后，本行结束马上调用析构销毁
      A(20); 
      //显示法
      A d = A(10); //调用有参构造
      A e = A(d); //调用拷贝构造
      
     
      
      //不要用初始化匿名拷贝构造，会被当成对象声明
      A(d);
      return 0;
  }
  ```

  

​	   
