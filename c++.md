# 基础语法

## new

> **类似`malloc`，在堆区开辟一块空间，返回指针**

```c++
int *p = new int(10);	
int *p_arr = new int[10];
int *p_arr1 = new int [3]{1, 2, 3};

delete p;
delete [] p_arr;
delete [] p_arr1;
```

## 引用&

> **给变量起别名**

```c++
int b = 10;
int &a = b; //a是b的别名， 别名一旦初始化，无法更改
int &c;  	//错误！！引用必须初始化
		 	
```

> **引用的本质**

```c++
int a = 10;

int &ref = a;		// 自动转换为int * const ref = &a;所以指针的指向不可改变
ref = 20; 			//内部发现是引用，自动转换为：*ref = 20;
```

> **常量引用** 

```C++
void int(const int a, const int b){...} //因为形参为引用，所以加const防止实参被修改
```

## 函数默认参数

> **用法**

```c++
//默认参数可以不传参，用默认的，如果传参就用自己的
//如果某个位置已经有了默认参数,那么从左往右都必须有默认参数
void test(int a, int b = 2, int c =5) {
    cout << a + b + c << endl;
}//test(100,100)  #输出205

//如果函数声明有默认参数，那么函数实现就不能有默认参数

void fun(int a = 10);
void fun(int a = 5) {	//错误！！重定义默认参数
    //
}

void fun(int a = 10);	//正确
void fun(int a) {	
   	cout <<  a + 5 << endl; //输出15
}


```

## 函数占位参数

> - **语法：返回值   函数名 (`数据类型`(占位参数1)， 数据类型 = `数据类型的一个值`(占位参数2))**
> - **在调用时的占位参数必须传一个与之对应的值**

```c++
//在调用fun1时第二个参数必须传一个整型的值
void fun1(int a, int) {
    //
}
//可以有默认值。。。
void fun2(int a, int = 10) {
    //
}
```

## 函数重载

- 函数重载的要求时，函数名相同，函数参数的类型，个数，大小可以不同
- 返回值不能作为重载的条件

## 面向对象

> **只记录自己容易忘记的**

- **构造函数**，只调用一次，如果没写，默认是一个参数为空的空实现，且可以重载

- **析构函数**，不可以有参数不可以发生重载，如果没写，默认空实现

- 如果一个类创建在堆区，没有主动释放，如没有`delete`，那么不会就不会调用析构，会造成内存泄漏

- **拷贝构造函数**

  ```c++
  class A {
      public:
      int age;
      
      A(){}
    	A(const A &a) { //拷贝构造函数
          age = a.age;
      }  
      A(int a) { //拷贝构造函数
          age = a.age;
      }  
  };
  
  int main () {
      A a;
      a.age = 5;
      A b(a);
      cout << b.age << endl; // 5
      
      A c(); //错误，会被当作函数声明！！函数名为c返回值为A类型
      
      //匿名对象，创建成功后，本行结束马上调用析构销毁
      A(20); 
      //显示法
      A d = A(10); //调用有参构造
      A e = A(d); //调用拷贝构造
      
     
      
      //不要用初始化匿名拷贝构造，会被当成对象声明
      A(d);
      return 0;
  }
  ```


## 拷贝构造函数

> C++调用时机常有三个

- 使用一个创建完毕的对象去初始化另一个对象	   

- 使用一个创建完毕的对象以值传递的方式，给函数参数传参

- 使用一个创建完毕的对象当参数返回值返回

  ```c++	
  /*使用一个创建完毕的对象去初始化另一个对象*/
  A a;
  A b(a);
  
  
  /*使用一个创建完毕的对象以值传递的方式，给函数参数传参*/
  void test01(A a) {
      //
  }
  int main() {
      A a;
      test01(a) //会触发拷贝构造
      return 0;
  }
  /*使用一个创建完毕的对象当参数返回值返回*/
  A test02() {		//会调用拷贝构造创建一个新的对象返回给调用者
   	A a;   			//&a ---0x4a6ef3ff
      return a;
  }
  
  int main() {
      A a = test02();	//&a ---0x6affeb31
      return 0;
  }
  
  ```


## 深拷贝和浅拷贝

> **深拷贝：**若成员属性中有开辟在堆区的指针，那么应该自定义一个拷贝构造函数，新开辟一块空间，然后赋值给这块空间，然后新地址传给当前对象
>
> **浅拷贝：**默认

## 静态成员变量和静态成员函数

> **静态成员变量：**在编译的时候就会分配空间，所以必须在类外初始化，所有类共享一个静态成员变量
>
> **静态成员函数：**只能访问静态成员属性

```c++
class Student {
public:
    static int age;
public:s
    static int getAge() {
        int tmp = age;
        return tmp;
    }

    Student& get_this() {
        cout << this << sizeof(this) << endl;
        return *this;
    }

};

int Student::age = 100; //必须在类外初始化

void main () {
    Student s;
    cout << Student::age << endl; //可以直接用类名访问
    cout << s.age << endl;
}
```

## 非静态成员变量归属于对象本身

> 只有非静态成员变量才属于对象，其他的都是共享的，若一个类全是静态成员变量或(静态)函数

## this指针

> 在非静态成员函数中指向调用函数的对象本身。

```c++
class A {
  int age;
  A(age) {
      this.age = age; /*---防止参数于成员变量的变量名相同----*/
  }
  
  A& fun() {	/* 必须调用要返回引用，不然会是个拷贝，不是同一个变量了 */
      cout << "a" << endl;
      return *this;		/* 返回对象本身 */
  }
    
};
void main() {
    A a;
    a.fun().fun().fun(); //a.fun() === a,所以可以链式调用
    
}
/**
输出：
	a
	a
	a
*/
```

## 常函数

> const修饰的成员函数叫常函数，常函数不能修改成员变量，除非成员变量用mutable修饰
>
> 常对象：用const修饰的对象，只能调用常函数

```
class B {
    int a;
    /* 
        this 指针本质是 B *const this 如果函数参数列表后加const，那么就变成		const B *const this 指针的指向以及指向的值均不可变 
    */
    void fun() const { 
    	a = 5; //错误！！ 不可修改

        
    }
};

void main() {
//b为常对象，只能调用常函数，且常对象的属性不可修改，除非是用mutable修饰
	const B b; 
}
```

